<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Anh Duy's blog</title>
        <link>https://anhduy.io</link>
        <description><![CDATA[]]></description>
        <atom:link href="https://anhduy.io/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Thu, 08 Feb 2018 00:00:00 UT</lastBuildDate>
        <item>
    <title>Monad transformer</title>
    <link>https://anhduy.io/posts/2018-02-08-monad-transformer.html</link>
    <description><![CDATA[<article>
    <section class="header">
        
    </section>
    <section>
        <p>This week, let’s talk about Haskell. I has been learning Haskell in my free time for a while and i am really enjoy it. I recommend everybody to learn it, whether you can use it for your day job or not, because it will give you a very different view and way of thinking to improve your programming skills.</p>
<p>Let’s start with a very simple problem likes this: given a user id, we want to find all posts of that user.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Post</span> <span class="fu">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">type</span> <span class="dt">UserId</span> <span class="fu">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">data</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">User</span> {<span class="ot"> _userId ::</span> <span class="dt">UserId</span> }</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">findUser ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">User</span>)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">findUser <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="ot">findPost ::</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> [<span class="dt">Post</span>])</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">findPost <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb1-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="ot">getPosts ::</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> [<span class="dt">Post</span>])</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">getPosts userId <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  maybeUser <span class="ot">&lt;-</span> findUser userId</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  <span class="kw">case</span> maybeUser <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15">    <span class="dt">Just</span> user <span class="ot">-&gt;</span> findPost user</a>
<a class="sourceLine" id="cb1-16" data-line-number="16">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return <span class="dt">Nothing</span></a></code></pre></div>
<p>First, we find the user by calling <code>findUser</code>. If we find the user, we will call <code>findPost</code> to get all posts of that user. Notice the implementation of <code>getPosts</code>, we need to unwrap <code>Maybe</code>, pattern match on it.</p>
<p><em>In case you are new to Haskell, <code>IO</code> is the monad that allows you do IO side effect in Haskell, read file, print to console, make network, api call. <code>Maybe</code> is another monad to represent computation that might go wrong by not returning a value. So when you see <code>Maybe User</code>, it means this function may return a user, may be not. That’s why we need to check if the <code>Maybe</code> value is <code>Just</code> or <code>Nothing</code>. And <code>IO (Maybe User)</code> means this function will make some IO call to outside, can read a file, query database and returns a <code>Maybe User</code>.</em></p>
<p>Let’s have another example to see the problem more clearly. Now we has another requirement, only friends can see all posts of each other. So we need to check friend relationship before return all posts.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">isFriend ::</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">isFriend <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ot">getFriendPosts ::</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> [<span class="dt">Post</span>])</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">getFriendPosts userId friendId <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  maybeUser <span class="ot">&lt;-</span> findUser userId</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  <span class="kw">case</span> maybeUser <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">    <span class="dt">Just</span> user <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">      maybeFriendUser <span class="ot">&lt;-</span> findUser friendId</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">      <span class="kw">case</span> maybeFriendUser <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">        <span class="dt">Just</span> friendUser <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">          maybeIsFriend <span class="ot">&lt;-</span> getRelationShip user friendUser</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">          <span class="kw">case</span> maybeIsFriend <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14">            <span class="co">-- I really want to give up this blog post at this point.</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15">            <span class="dt">Just</span> isFriend <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-16" data-line-number="16">              <span class="kw">if</span> isFriend</a>
<a class="sourceLine" id="cb2-17" data-line-number="17">              <span class="kw">then</span> </a>
<a class="sourceLine" id="cb2-18" data-line-number="18">                getPosts friendId</a>
<a class="sourceLine" id="cb2-19" data-line-number="19">              <span class="kw">else</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">                return <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb2-21" data-line-number="21">            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb2-22" data-line-number="22">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb2-23" data-line-number="23">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return <span class="dt">Nothing</span></a></code></pre></div>
<p>Now, the code looks really ugly now. We have a deep nested code, each step we need to manual unwrap <code>Maybe</code> value, process if it has value, otherwise return <code>Nothing</code>. This looks really bad not only because of nested steps, but also because we can’t leverage <code>Maybe</code> monad feature.</p>
<p>Let’s recall the <code>Monad</code> instance of <code>Maybe</code> and <code>IO</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="dt">Nothing</span> <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="dt">Just</span> x <span class="fu">&gt;&gt;</span> f <span class="fu">=</span> f x</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="co">-- This is not the real implementation of IO monad but you can get the idea</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">IO</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  (action1 <span class="fu">&gt;&gt;=</span> action2) world0 <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    <span class="kw">let</span> (a, world1) <span class="fu">=</span> action1 world0</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">        (b, world2) <span class="fu">=</span> action2 a world1</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    <span class="kw">in</span> (b, world2)</a></code></pre></div>
<p>In <code>Maybe</code> monad, the computation chains will stop when <code>Nothing</code> is returned from any computation, so <code>Nothing &gt;&gt;= f</code> will return <code>Nothing</code>. In <code>IO</code> monad, it will run each computation sequencely. So if we mix them together, our <code>IO Maybe</code> mond which behave like <code>IO</code> normal monad. But in this case, we want our <code>IO Maybe</code> to also have behaviour of <code>Maybe</code> monad. If any computation returns <code>Nothing</code>, it should stop and return <code>Nothing</code>.</p>
<p><em><code>do</code> notation is a syntax sugar in haskell</em></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">run <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  runA</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  runB</a></code></pre></div>
<p><em>is</em></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">run <span class="fu">=</span> runA <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> runB</a></code></pre></div>
<p>So the main problem here is we use two monad <code>IO</code> and <code>Maybe</code> together, and right now they don’t work well with each other. We only use feature of <code>IO</code> monad and not <code>Maybe</code> monad. To illustrate the idea, here is what will happens if we write our code with only <code>Maybe</code> monad.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Post</span> <span class="fu">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">type</span> <span class="dt">UserId</span> <span class="fu">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">data</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">User</span> {<span class="ot"> _userId ::</span> <span class="dt">UserId</span> }</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="ot">findUser ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">User</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">findUser <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb6-7" data-line-number="7"></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="ot">findPost ::</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Post</span>]</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">findPost <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb6-10" data-line-number="10"></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="ot">getPosts ::</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Post</span>]</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">getPosts userId <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  user <span class="ot">&lt;-</span> findUser userId</a>
<a class="sourceLine" id="cb6-14" data-line-number="14">  findPost user</a>
<a class="sourceLine" id="cb6-15" data-line-number="15"></a>
<a class="sourceLine" id="cb6-16" data-line-number="16"><span class="ot">isFriend ::</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">isFriend <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb6-18" data-line-number="18"></a>
<a class="sourceLine" id="cb6-19" data-line-number="19"><span class="ot">getFriendPosts ::</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Post</span>]</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">getFriendPosts userId friendId <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-21" data-line-number="21">  user <span class="ot">&lt;-</span> findUser userId</a>
<a class="sourceLine" id="cb6-22" data-line-number="22">  friend <span class="ot">&lt;-</span> findUser friendId</a>
<a class="sourceLine" id="cb6-23" data-line-number="23">  friendCheck <span class="ot">&lt;-</span> isFriend user friend</a>
<a class="sourceLine" id="cb6-24" data-line-number="24">  <span class="kw">if</span> friendCheck</a>
<a class="sourceLine" id="cb6-25" data-line-number="25">  <span class="kw">then</span></a>
<a class="sourceLine" id="cb6-26" data-line-number="26">    getPosts friendId</a>
<a class="sourceLine" id="cb6-27" data-line-number="27">  <span class="kw">else</span></a>
<a class="sourceLine" id="cb6-28" data-line-number="28">    <span class="dt">Nothing</span></a></code></pre></div>
<p>It looks nicer, right? We don’t need to check for <code>Just</code> and <code>Nothing</code> at every step, we depend on the monad instance of <code>Maybe</code> to take care of it.</p>
<p>If only we can make our <code>IO Maybe</code> behave like both <code>IO</code>, which can make IO call to outside world, and <code>Maybe</code>, represent a computation may return nothing and stop as soon as one function returns <code>Nothing</code>, we will be able to make the code above less verbose and more expressive. Let’s try to create that new monad together, we will call it <code>MaybeIO</code> monad.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">MaybeIO</span> a <span class="fu">=</span> <span class="dt">MaybeIO</span> {<span class="ot"> runMaybeIO ::</span> <span class="dt">IO</span>(<span class="dt">Maybe</span> a) }</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">findUser ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">MaybeIO</span> <span class="dt">User</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">findUser <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"><span class="ot">findPost ::</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">MaybeIO</span> [<span class="dt">Post</span>]</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">findPost <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="ot">isFriend ::</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">MaybeIO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">isFriend <span class="fu">=</span> undefined</a></code></pre></div>
<p>Now before we rewrite <code>getFriendPosts</code>, we need to provide monad instance for our <code>MaybeIO</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">MaybeIO</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  fmap f <span class="fu">=</span> <span class="dt">MaybeIO</span> <span class="fu">.</span> fmap (fmap f) <span class="fu">.</span> runMaybeIO</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">MaybeIO</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  pure a <span class="fu">=</span> <span class="dt">MaybeIO</span> <span class="fu">$</span> return (<span class="dt">Just</span> a)</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  f <span class="fu">&lt;*&gt;</span> a <span class="fu">=</span> <span class="dt">MaybeIO</span> <span class="fu">$</span> (<span class="fu">&lt;*&gt;</span>) <span class="fu">&lt;$&gt;</span> (runMaybeIO f) <span class="fu">&lt;*&gt;</span> (runMaybeIO a)</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">MaybeIO</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">  return a <span class="fu">=</span> <span class="dt">MaybeIO</span> <span class="fu">$</span> return (<span class="dt">Just</span> a)</a>
<a class="sourceLine" id="cb8-10" data-line-number="10"></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">MaybeIO</span> <span class="fu">$</span> runMaybeIO x <span class="fu">&gt;&gt;=</span> \a <span class="ot">-&gt;</span> <span class="kw">case</span> a <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">      <span class="dt">Just</span> value <span class="ot">-&gt;</span> runMaybeIO <span class="fu">$</span> f value</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return <span class="dt">Nothing</span></a></code></pre></div>
<p>Basically remember our <code>MaybeIO</code> is actually <code>IO Maybe</code>, so we write our new monad based on functionality of these two. For the <code>(&gt;&gt;=)</code> function, we called <code>runMaybeIO x</code>, which return us a <code>IO Maybe</code>. Then we use <code>(&gt;&gt;=)</code> instance of <code>IO</code> to get back a, which is <code>Maybe</code> monad.</p>
<p>If you confuse because of <code>runMaybeIO</code> and <code>MaybeIO</code> constructor, here are their signatures:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="dt">MaybeIO</span><span class="ot"> ::</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> <span class="dt">MaybeIO</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="ot">runMaybeIO ::</span> <span class="dt">MaybeIO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> a)</a></code></pre></div>
<p>We use them to convert between our new <code>MaybeIO</code> monad and the original <code>IO Maybe</code>.</p>
<p>Now it’s time to rewrite our <code>getFriendPosts</code></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">getFriendPosts ::</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">MaybeIO</span> [<span class="dt">Post</span>]</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">getFriendPosts userId friendId <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  user <span class="ot">&lt;-</span> findUser&#39; userId</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  friend <span class="ot">&lt;-</span> findUser&#39; friendId</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  friendCheck <span class="ot">&lt;-</span> isFriend&#39; user friend</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  <span class="kw">if</span> friendCheck</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  <span class="kw">then</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">    getPosts&#39; friendId</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">  <span class="kw">else</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10">    return mempty</a></code></pre></div>
<p>It looks like the example with <code>Maybe</code> monad above, right? We’ve just combined <code>IO</code> and <code>Maybe</code> together into a single monad, which behave like <code>Maybe</code> and have <code>IO</code> capability. If we go one step further, generalize it, instead of <code>MaybeIO</code>, we want to use <code>Maybe</code> with any other monad, add <code>Maybe</code> behaviour to it.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">MaybeT</span> m a <span class="fu">=</span> <span class="dt">MaybeT</span> {<span class="ot"> runMaybeT ::</span> m(<span class="dt">Maybe</span> a) }</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">MaybeT</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  fmap f <span class="fu">=</span> <span class="dt">MaybeT</span> <span class="fu">.</span> fmap (fmap f) <span class="fu">.</span> runMaybeT</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">MaybeT</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  pure a <span class="fu">=</span> <span class="dt">MaybeT</span> <span class="fu">$</span> return (<span class="dt">Just</span> a)</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  f <span class="fu">&lt;*&gt;</span> a <span class="fu">=</span> <span class="dt">MaybeT</span> <span class="fu">$</span> (<span class="fu">&lt;*&gt;</span>) <span class="fu">&lt;$&gt;</span> (runMaybeT f) <span class="fu">&lt;*&gt;</span> (runMaybeT a)</a>
<a class="sourceLine" id="cb11-9" data-line-number="9"></a>
<a class="sourceLine" id="cb11-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">MaybeT</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-11" data-line-number="11">  return a <span class="fu">=</span> <span class="dt">MaybeT</span> <span class="fu">$</span> return (<span class="dt">Just</span> a)</a>
<a class="sourceLine" id="cb11-12" data-line-number="12"></a>
<a class="sourceLine" id="cb11-13" data-line-number="13">  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">MaybeT</span> <span class="fu">$</span> runMaybeT x <span class="fu">&gt;&gt;=</span> \a <span class="ot">-&gt;</span> <span class="kw">case</span> a <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-14" data-line-number="14">      <span class="dt">Just</span> value <span class="ot">-&gt;</span> runMaybeT <span class="fu">$</span> f value</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return <span class="dt">Nothing</span></a></code></pre></div>
<p>Instead of <code>MaybeIO</code>, we have <code>MaybeT m</code> with m is another monad such as <code>IO</code>. Our <code>MaybeIO</code> above become <code>MaybeT IO</code>. We have finished written our first Monad Transformer, MaybeT.</p>
<p>Monad Transformer allows us to stack multiple monads together and behave likes one single monad, combined all functionalities of these monads inside the stack. For example, if we want to build a real application, we need to read global config (<code>Reader</code> monad), write log (<code>Writer</code> monad), store application state (<code>State</code> monad), handling exception (<code>Either</code> monad), and of course <code>IO</code> monad. We can write a <code>ReaderT AppConfig (WriterT String (StateT AppState (ExceptT String IO)))</code> monad to represent our application and reuse all functionality of these monads.</p>
<p>That’s all for this post. We saw two real world problems. We learn to write a custom <code>MaybeIO</code> monad which combined <code>Maybe</code> and <code>IO</code> together to solve the problem. After that we generalize it into <code>MaybeT</code> monad transformer and learn how monad transformer can help us in real application by stack multiple monad together.</p>
<p>Next time, we will look at <code>mtl</code> and <code>transformers</code>, two monad transformer libraries in Haskell ecosystem, which provide us the transformer version of all standard monads so we don’t need to write our own. We will also look at the order of the monad in the stack and how it will effect behaviour of the whole stack.</p>
<p>Thank you.</p>
    </section>
    <section class="footer">
        February  8, 2018
    </section>
    <section class="license">
	    <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.
    </section>
</article>
]]></description>
    <pubDate>Thu, 08 Feb 2018 00:00:00 UT</pubDate>
    <guid>https://anhduy.io/posts/2018-02-08-monad-transformer.html</guid>
    <dc:creator>Anh Duy</dc:creator>
</item>
<item>
    <title>RPC</title>
    <link>https://anhduy.io/posts/2018-01-21-rpc.html</link>
    <description><![CDATA[<article>
    <section class="header">
        
    </section>
    <section>
        <p>Second posts of the week, this time I have a more interesting topic to share. Let’s talk about RPC, more specificly gRPC.</p>
<p>After a few years working as software developer, i heard about RPC a few times. It was mentioned liked an outdated, no longer suitable, nobody used, pre-1990 kind of technology so i’d actually looked at it. Then come this week, i was reading about how to use Swagger[0] to define schema and structure for REST api. At first it’s quite interesting when you can defined a Swagger spec, then use it as a spec to run against your code to verify your code. It works well but … i don’t think it’s enough. It seems like writing document and the problem with document is it very easy to outdated. Even use it as spec, it only cover one senario, if i calls it with different request body, will it return me a different data structure? After learning Haskell, i prefer using a static, strict type, predefined data structure than using a dynamic type, with flexible json body and writing more tests to cover it. I believe in my tests but as the same time, i always know i don’t have enough tests. So I tried to find if there is any better solution out there.</p>
<p><em>I can’t remember exactly how i find RPC when i was searching for the answer. But anyway, let’s ignore it.</em></p>
<p>What’s is RPC? RPC stands for remote procedure call, which defined as when a computer program causes a procedure (subroutine) to execute in a different address space (commonly on another computer on a shared network), which is coded as if it were a normal (local) procedure call, without the programmer explicitly coding the details for the remote interaction [1]. Meaning you have two processes A and B in same machine, you can use RPC to call B procedure from A. You can also call a RPC of C from a different machine in the network or somewhere on internet. Does that sound familier to you?</p>
<p>My first thought is what is the different between that and (so called) REST api that i wrote?</p>
<p>But wait, before that, what’s REST api? I suggest to search the internet for Roy Fielding papaer that decribes and coined the term REST [2]. I think most of people, whom I know, included me, misunderstand REST api and call something very different REST api [3].</p>
<p>Right now most of REST api i know works likes this: you have a fixed url, <code>https://example.com/api/posts</code>, then you can use http verb such as <code>GET</code>, <code>POST</code>, <code>PATCH</code> or <code>DELETE</code> to interact with that endpoint to query, create, modify or delete that <code>post</code> resource. Also you need to read the doc somewhere which tell you what should be included in the body to send request, what is the response will be. So what’s wrong with it?</p>
<p>That’s not REST api, or at least it isn’t what Roy Fielding decribed in his paper. And problem starts from there.</p>
<p>That kind of api isn’t REST, and the more interesting thing is it sounds exaclty like RPC. Your server and client are coupling by a fixed url, if server changes the url, all client will be crashed. Your server and client depend on fixed data structure (json, xml, form data), if you want to change the request or response, all of your client need to be updated or the server will reject the request (or client doesn’t understand the response). Your REST api is actually a remote procedure call.</p>
<p>So what? Nothing. It’s totally fine if your REST api is actually RPC, I never see a real implementation of Roy Fielding REST api in the wild, now REST api is the api above, everybody agree on that.</p>
<p>But let’s take a step back and think about this. If you don’t accept that your api is RPC, which it means you implement it in a way that decoupling client and server, they can change quite independently, your client can detect and discover a url changes, understand media types … Then the rest of this post won’t apply to you (and please send/show me how to do that). If you accept that maybe your REST api is the same as RPC, maybe it’s not but it has same limitation without any extra benefits, maybe the nature of your client and server always couling to each other, then maybe we can find a better solution to implement communication between client and server.</p>
<p>Into gRPC [4], I use it here as an example of a (maybe) better alternate to your normal REST api. gRPC itself is a RPC implementation that use HTTP/2 as transport protocol and use protobuf for serialize structured data exchanged between client and server. You basically write a proto (protobuf file) spec first, which contains definition of the service, how to call it, how many arguments does it has, structure of the request and response data. Everything will be written down first in proto file, and then from that, you can generate code to your preference languages: go, ruby, java (c, haskell and rust also supported from community).</p>
<p>So what is the different now? Everything is well defined, code is auto generated for client and server, there won’t be any type or structure problem whatsoever. If server updates their spec, their proto file will changes. You will know and update your client to work with new spec. Everything is transparent and easy, problem such as someone silently update their service and your service starts to fail without any reason, a missing field or wrong json data or a string instead of an int. Also, client can choice to update to get new service or information from the response, or <strong>not</strong> to update and still be compatiable with the server. Some one add extra fields in server and you don’t need that fields? Just ignore it, don’t care, no need to do anything.</p>
<p>That’s the reason i think gRPC is a better solution. It has right balance of strictness and flexibility. It’s strict when come to contracts both client and server use. But it’s also flexible when come to changes, you can update or keep the current version and still compatiable.</p>
<p>I guess that’s it for now, there will be another post about using gRPC but for now, think about this: Is it better for your current system if you replce what you call REST api with this gRPC?</p>
<p>Thank you and see you next time.</p>
<p>[0] https://swagger.io/</p>
<p>[1] https://en.wikipedia.org/wiki/Remote_procedure_call</p>
<p>[2] https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</p>
<p>[3] Actually, REST is not the only or first term that people mostly use it wrong. The same goes for OOP, MVC …</p>
<p>[4] https://grpc.io/</p>
<p>P/S: sorry for this ugly reference links, i will fix it later.</p>
    </section>
    <section class="footer">
        January 21, 2018
    </section>
    <section class="license">
	    <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.
    </section>
</article>
]]></description>
    <pubDate>Sun, 21 Jan 2018 00:00:00 UT</pubDate>
    <guid>https://anhduy.io/posts/2018-01-21-rpc.html</guid>
    <dc:creator>Anh Duy</dc:creator>
</item>
<item>
    <title>Vim package management</title>
    <link>https://anhduy.io/posts/2018-01-18-vim-package.management.html</link>
    <description><![CDATA[<article>
    <section class="header">
        
    </section>
    <section>
        <p>Wellcome back, it’s been a week since my first post. This week i want to write about new vim 8 pacakge management.</p>
<p>Before vim 8, to manage plugins, normally you need to install a third-party plugin management such as Pathogen, vim-plug… but starting from vim 8, you can use built-in vim package management to do that.</p>
<p>First, let’s upgrade vim to version 8. You can install it using your OS package management (pacman, brew, …), just make sure it is version 8.</p>
<p><em>I should probably introduce more about vim, but there are some plugins i can’t live without so I need to setup package management first. I promise i will introduce how to use vim later.</em></p>
<p>Here is how vim 8 package management work:</p>
<pre><code>.vim
└── pack
    └── anhduy
        ├── opt
        └── start</code></pre>
<ul>
<li><code>anhduy</code>: You can name this directory whatever you want, vim doesn’t care about this folder name.</li>
<li><code>start</code>: Always loaded plugins directory: put the plugin you want vim to load here.</li>
<li><code>opt</code>: Optional plugins directory: vim will not load plugins inside this folder unless you ask it to by running <code>:packadd</code>.</li>
</ul>
<p>Now, if you want to install <a href="https://github.com/ctrlpvim/ctrlp.vim">ctrlp</a>, just clone it into <code>start</code> and vim will autoload it.</p>
<p>Try another one, clone <a href="https://github.com/majutsushi/tagbar">Tagbar</a> into <code>opt</code>, then confirm that you can’t run <code>:Tagbar</code> until you run <code>:packadd tagbar</code> first.</p>
<p>That’s all of it, now you can use plugins with vim itself without any other tools.</p>
<p>Questions from (imagination) readers:</p>
<pre><code>Q: What do you mean by &quot;clone it into start&quot;?
A: That&#39;s a git specific term, basically it mean you copy the whole folder and put it inside start directory.</code></pre>
<pre><code>Q: Can vim package management allow me to define plugins in vimrc or have command to download plugins?
A: No, it only know how to load your plugins.</code></pre>
<pre><code>Q: So now my vimrc isn&#39;t the source of truth, which defined all my vim config anymore?
A: ...</code></pre>
<pre><code>Q: If i use this, how can i copy by vimrc to a server and use it, before that i have vim-plug download everything for me
A: ... ...</code></pre>
<pre><code>An early converted reader: I removed vim-plug and use vim 8 pacakge management now, it works fine, but how can i update my plugins?
A: ... ... ...</code></pre>
<pre><code>Another early converted: This thing is useless, it can&#39;t update my plugins likes vim-plug. How can i update my plugin :rage: ?
A: :dont-know: :who-care:</code></pre>
<pre><code>Others: Wait, wait, I don&#39;t understand, what should i do now, please answer above questions :crying:
A: :dun-care: :dun-care: :running-away:</code></pre>
<p>Thanks for reading, see you again next time on how to setup and use vim as main editor.</p>
    </section>
    <section class="footer">
        January 18, 2018
    </section>
    <section class="license">
	    <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.
    </section>
</article>
]]></description>
    <pubDate>Thu, 18 Jan 2018 00:00:00 UT</pubDate>
    <guid>https://anhduy.io/posts/2018-01-18-vim-package.management.html</guid>
    <dc:creator>Anh Duy</dc:creator>
</item>
<item>
    <title>New blog</title>
    <link>https://anhduy.io/posts/2018-01-06-new-blog.html</link>
    <description><![CDATA[<article>
    <section class="header">
        
    </section>
    <section>
        <p>It’s 2018, I think it’s time for me to start writing blog posts. A lot of people told me writing will improve my thinking, my understanding on the topic i write. Also, by writing, I hope I can share things I am passionate about to larger audience.</p>
<p>I will mainly write posts about these topics:</p>
<ul>
<li>Strong typed language: after learning a bit of Haskell and Idris, I am very interested in how these languages can help us write better software.</li>
<li>Unix-like system and cli tools: I spend most of my time in tmux and vim, I believe terminal apps can help you boost your productivity a lot compared to GUI app. Also I would like to understand more about Unix-like system. I am using Arch linux but also keep an eye on NixOS.</li>
<li>Devops tools: vm, container, scheduler … One day I will control one thousand servers by myself.</li>
<li>Others: can be random topics that catches my attention, such as c, compiler, build x from scratch or how special Nier: Automata is and you should play it.</li>
</ul>
<p>That’s it for the first post to test out my setup, see you next week.</p>
<p><em>P/S: Did you know you can read this blog without JavaScript? And yes, it’s responsive.</em></p>
    </section>
    <section class="footer">
        January  6, 2018
    </section>
    <section class="license">
	    <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.
    </section>
</article>
]]></description>
    <pubDate>Sat, 06 Jan 2018 00:00:00 UT</pubDate>
    <guid>https://anhduy.io/posts/2018-01-06-new-blog.html</guid>
    <dc:creator>Anh Duy</dc:creator>
</item>

    </channel>
</rss>
